import mongoose from 'mongoose';
import slugPlugin from '@classytic/mongoose-slug-plugin';

const { Schema } = mongoose;

const imageSchema = new Schema({
  url: { type: String, required: true, trim: true },
  variants: {
    thumbnail: { type: String, trim: true },
    medium: { type: String, trim: true },
  },
  order: { type: Number, default: 0 },
  isFeatured: { type: Boolean, default: false },
  alt: { type: String, trim: true },
}, { _id: false });

const dimensionsCmSchema = new Schema({
  length: { type: Number, min: 0 },
  width: { type: Number, min: 0 },
  height: { type: Number, min: 0 },
}, { _id: false });

const shippingSchema = new Schema({
  weightGrams: { type: Number, min: 0 },
  dimensionsCm: dimensionsCmSchema,
}, { _id: false });

/**
 * Variation Attribute Schema (defines what variations exist)
 * e.g., { name: "Size", values: ["S", "M", "L"] }
 */
const variationAttributeSchema = new Schema({
  name: { type: String, required: true },       // e.g., "Size", "Color"
  values: [{ type: String, required: true }],   // e.g., ["S", "M", "L"]
}, { _id: false });

/**
 * Variant Schema (explicit sellable combinations)
 * Generated by backend from variationAttributes
 * e.g., { sku: "TSHIRT-S-RED", attributes: { size: "S", color: "Red" } }
 */
const variantSchema = new Schema({
  sku: { type: String, required: true, trim: true },
  barcode: { type: String, trim: true },
  attributes: { type: Map, of: String },        // e.g., { size: "S", color: "Red" }
  priceModifier: { type: Number, default: 0 },
  costPrice: { type: Number, min: 0, default: 0 },
  images: [imageSchema],
  shipping: shippingSchema,
  isActive: { type: Boolean, default: true },   // User can disable specific variants
  // VAT rate override for this specific variant (null = use product/category/platform rate)
  vatRate: { type: Number, min: 0, max: 100, default: null },
}, { _id: false });

// Legacy schemas removed - using canonical variant structure only

const discountSchema = new Schema({
  type: { type: String, enum: ['percentage', 'fixed'], required: true },
  value: { type: Number, required: true, min: 0 },
  startDate: Date,
  endDate: Date,
  description: String,
}, { _id: false });

const statsSchema = new Schema({
  totalSales: { type: Number, default: 0 },
  totalQuantitySold: { type: Number, default: 0 },
  viewCount: { type: Number, default: 0 },
}, { _id: false });

const stockProjectionSchema = new Schema({
  variants: [{
    sku: { type: String, trim: true },
    quantity: { type: Number, default: 0 },
  }],
  syncedAt: Date,
}, { _id: false });

/**
 * Product Schema
 * 
 * Category: simple string, frontend-defined
 * Slug: auto-generated from name, globally unique
 */
const productSchema = new Schema({
  name: { type: String, required: true, trim: true },
  // Uniqueness enforced via schema index (see indexes section).
  slug: { type: String },
  shortDescription: { type: String, trim: true },
  description: String,
  basePrice: { type: Number, required: true, min: 0 },
  costPrice: { type: Number, min: 0, default: 0 },
  // Cached total stock across all branches (synced from StockEntry)
  // Source of truth lives in inventory/StockEntry
  quantity: { type: Number, default: 0, min: 0 },

  // Product type: simple or variant
  // - simple: no variants, tracks inventory with variantSku=null
  // - variant: has variants[], tracks inventory per variant SKU
  productType: {
    type: String,
    enum: ['simple', 'variant'],
    default: 'simple',
  },

  // SKU & Barcode (for simple products without variants)
  sku: { type: String, trim: true },
  barcode: { type: String, trim: true },

  images: [imageSchema],

  // Category slug (references Category.slug, not ObjectId)
  // This enables direct string queries without $lookup
  category: { type: String, required: true, trim: true, lowercase: true },
  parentCategory: { type: String, trim: true, lowercase: true, default: null },

  // Style tags (enum set) for quick filtering like ?style=street
  style: [{
    type: String,
    // enum: ['casual', 'street', 'urban', 'desi', 'formal', 'sport', 'ethnic', 'party'],
  }],

  // NEW: Variation attributes (defines what variations exist)
  // e.g., [{ name: "Size", values: ["S", "M", "L"] }, { name: "Color", values: ["Red", "Blue"] }]
  variationAttributes: [variationAttributeSchema],

  // Explicit variants (generated from variationAttributes by backend)
  // Each variant is a sellable combination with its own SKU
  variants: [variantSchema],

  // Shipping attributes used for delivery charge estimation (e.g., RedX charge calculator)
  // Values are optional; when missing, checkout/shipping logic will treat metrics as unknown.
  shipping: shippingSchema,

  properties: Schema.Types.Mixed,
  tags: [String],

  stats: { type: statsSchema, default: () => ({}) },

  // Read-only stock projection for fast variant availability checks
  // Synced from StockEntry after stock movements
  stockProjection: { type: stockProjectionSchema, default: () => ({ variants: [] }) },

  averageRating: { type: Number, default: 0, min: 0, max: 5 },
  numReviews: { type: Number, default: 0, min: 0 },

  discount: discountSchema,
  isActive: { type: Boolean, default: true },

  // VAT configuration (product-specific rate override)
  // null = use category rate (or platform default if category has no rate)
  // This enables product-level tax exceptions within a category
  // Example: Educational electronics exempt (0%) while other electronics are 15%
  vatRate: {
    type: Number,
    min: 0,
    max: 100,
    default: null,
  },

  // Soft delete - when set, product is considered deleted but data preserved
  // Use this instead of hard delete to preserve order history references
  deletedAt: { type: Date, default: null },
}, { timestamps: true });

// Minimal indexes - only what's essential
// Unique slug for SEO URLs
productSchema.index({ slug: 1 }, { unique: true });
productSchema.index({ category: 1 });
productSchema.index({ name: 'text', description: 'text', tags: 'text' });
productSchema.index({ createdAt: -1, _id: -1 }); // Pagination

// SKU & Barcode must be globally unique when provided (POS scanning safety).
// Use partial indexes so null/undefined values don't collide.
productSchema.index({ sku: 1 }, { unique: true, partialFilterExpression: { sku: { $type: 'string' } } });
productSchema.index(
  { barcode: 1 },
  { unique: true, partialFilterExpression: { barcode: { $type: 'string' } } }
);
// Variant identifiers must also be globally unique when provided.
// Partial index avoids null collisions from incomplete/legacy docs during dev.
productSchema.index(
  { 'variants.sku': 1 },
  { unique: true, partialFilterExpression: { 'variants.sku': { $type: 'string' } } }
);
productSchema.index(
  { 'variants.barcode': 1 },
  { unique: true, partialFilterExpression: { 'variants.barcode': { $type: 'string' } } }
);

// Soft delete TTL index is created by softDeletePlugin with ttlDays option

// Auto-slug from name (updateOnChange: regenerate slug when name is updated)
productSchema.plugin(slugPlugin, {
  sourceField: 'name',
  slugField: 'slug',
  updateOnChange: true,
});

// Virtuals
productSchema.virtual('isDiscountActive').get(function () {
  if (!this.discount?.startDate || !this.discount?.endDate) return false;
  const now = new Date();
  return this.discount.startDate <= now && this.discount.endDate >= now;
});

productSchema.virtual('currentPrice').get(function () {
  if (this.isDiscountActive) {
    const { type, value } = this.discount;
    if (type === 'percentage') return this.basePrice * (1 - value / 100);
    if (type === 'fixed') return Math.max(this.basePrice - value, 0);
  }
  return this.basePrice;
});

productSchema.virtual('featuredImage').get(function () {
  if (!this.images?.length) return null;
  return this.images.find(img => img.isFeatured) || this.images[0];
});

productSchema.virtual('totalSales').get(function () {
  return this.stats?.totalSales || 0;
});

productSchema.virtual('profitMargin').get(function () {
  if (!this.costPrice) return null;
  const sellPrice = this.currentPrice; // Uses discount if active
  return sellPrice - this.costPrice;
});

productSchema.virtual('profitMarginPercent').get(function () {
  if (!this.costPrice || this.currentPrice === 0) return null;
  const margin = this.currentPrice - this.costPrice;
  return (margin / this.currentPrice) * 100;
});

productSchema.virtual('isDeleted').get(function () {
  return this.deletedAt != null;
});

productSchema.set('toJSON', { virtuals: true });
productSchema.set('toObject', { virtuals: true });

// Product type invariant validation
productSchema.pre('save', async function () {
  // Always derive product type from variant data to prevent mismatches
  const hasVariants = Array.isArray(this.variants) && this.variants.length > 0;
  const hasVariationAttributes = Array.isArray(this.variationAttributes) && this.variationAttributes.length > 0;
  this.productType = hasVariants || hasVariationAttributes ? 'variant' : 'simple';

  // Validate invariants
  if (this.productType === 'simple') {
    if (this.variants?.length > 0 || this.variationAttributes?.length > 0) {
      throw new Error('Simple products cannot have variants or variationAttributes');
    }
  }

  if (this.productType === 'variant') {
    if (!this.variants?.length || !this.variationAttributes?.length) {
      throw new Error('Variant products must have both variants[] and variationAttributes[]');
    }
  }
});

const Product = mongoose.models.Product || mongoose.model('Product', productSchema);
export default Product;
